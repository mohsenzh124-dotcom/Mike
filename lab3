## Задача 1: Базовый класс "Студент"

#include <iostream>
#include <string>
using namespace std;

class Student {
private:
    // Private fields: name, age, average grade, and grades array (5 elements)
    string name;
    int age;
    double averageGrade;
    int grades[5];

public:
    // Constructor with parameters
    Student(string n, int a) : name(n), age(a), averageGrade(0.0) {
        for (int i = 0; i < 5; ++i) {
            grades[i] = 0;
        }
    }

    // Getters
    string getName() const {
        return name;
    }

    int getAge() const {
        return age;
    }

    double getAverageGrade() const {
        return averageGrade;
    }

    int getGrade(int index) const {
        if (index >= 0 && index < 5) {
            return grades[index];
        }
        return -1; // Error code
    }

    // Setters with validation
    void setName(string newName) {
        if (!newName.empty()) {
            name = newName;
        } else {
            cout << "Error: name cannot be empty" << endl;
        }
    }

    void setAge(int newAge) {
        if (newAge >= 16 && newAge <= 100) {
            age = newAge;
        } else {
            cout << "Error: age must be between 16 and 100 years" << endl;
        }
    }

    void setGrade(int index, int grade) {
        if (index < 0 || index >= 5) {
            cout << "Error: index must be between 0 and 4" << endl;
            return;
        }
        if (grade >= 1 && grade <= 5) {
            grades[index] = grade;
            calculateAverage(); // Recalculate average grade
        } else {
            cout << "Error: grade must be between 1 and 5" << endl;
        }
    }

    void calculateAverage() {
        double sum = 0;
        for (int i = 0; i < 5; ++i) {
            sum += grades[i];
        }
        averageGrade = sum / 5.0;
    }

    void displayInfo() const {
        cout << "Student: " << name << endl;
        cout << "Age: " << age << " years" << endl;
        cout << "Average Grade: " << averageGrade << endl;
        cout << "Grades: ";
        for (int i = 0; i < 5; ++i) {
            cout << grades[i];
            if (i < 4) cout << ", ";
        }
        cout << endl;
    }

    bool hasScholarship() const {
        return averageGrade >= 4.5;
    }
};

int main() {
    Student student("Ivan Ivanov", 20);
    
    student.setGrade(0, 5);
    student.setGrade(1, 4);
    student.setGrade(2, 5);
    student.setGrade(3, 3);
    student.setGrade(4, 4);
    
    student.displayInfo();
    
    if (student.hasScholarship()) {
        cout << "Student receives scholarship" << endl;
    } else {
        cout << "No scholarship awarded" << endl;
    }

 
    // Validation tests
    student.setGrade(10, 5); // Invalid index
    student.setGrade(2, 6);  // Invalid grade
    student.setAge(15);      // Invalid age
    
    // Data modification
    student.setName("Ivan Petrov");
    student.setAge(21);
    
    student.displayInfo();

    return 0;
}

##Задача 2: Наследование - Академические работники

#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Person {
protected:
    string name;
    int age;
    string address;

public:
    Person(string n, int a, string addr) : name(n), age(a), address(addr) {}
    virtual void displayInfo() const {
        cout << "Name: " << name << ", Age: " << age << ", Address: " << address;
    }
    virtual ~Person() {}
};

class Student : public Person {
private:
    string studentId;
    double averageGrade;
    int grades[5];

    void recalcAverage() {
        double s = 0;
        for (int i = 0; i < 5; ++i) s += grades[i];
        averageGrade = s / 5.0;
    }

public:
    Student(string n, int a, string addr, string id, double avg = 0.0)
        : Person(n, a, addr), studentId(id), averageGrade(avg) {
        for (int i = 0; i < 5; ++i) grades[i] = 0;
    }

    void setGrade(int idx, int value) {
        if (idx < 0 || idx >= 5) {
            cerr << "Error: Invalid grade index\n";
            return;
        }
        if (value < 1 || value > 5) {
            cerr << "Error: Grade must be between 1 and 5\n";
            return;
        }
        grades[idx] = value;
        recalcAverage();
    }

    double getAverage() const { return averageGrade; }
    string getStudentId() const { return studentId; }

    void displayInfo() const override {
        Person::displayInfo();
        cout << ", Student ID: " << studentId << ", Average Grade: " << averageGrade << "\n";
        cout << "Grades: ";
        for (int i = 0; i < 5; ++i) cout << grades[i] << (i + 1 < 5 ? " " : "\n");
    }
};

class Professor : public Person {
private:
    string department;
    double salary;
    int yearsOfExperience;

public:
    Professor(string n, int a, string addr, string dept, double sal, int yrs)
        : Person(n, a, addr), department(dept), salary(sal), yearsOfExperience(yrs) {
    }

    double calcExperienceBonus() const {
        double pct = 0.01 * yearsOfExperience;
        if (pct > 0.5) pct = 0.5;
        return salary * pct;
    }

    void displayInfo() const override {
        Person::displayInfo();
        cout << ", Department: " << department << ", Salary: " << salary
            << ", Experience: " << yearsOfExperience << " years"
            << ", Experience Bonus: " << calcExperienceBonus() << "\n";
    }
};

int main() {
    Student student("Peter Petrov", 20, "Student Street, 15", "S12345", 4.3);
    student.setGrade(0, 5);
    student.setGrade(1, 4);
    student.setGrade(2, 5);
    student.setGrade(3, 3);
    student.setGrade(4, 4);

    Professor prof("Dr. Ivanov", 45, "Academic Street, 10", "Computer Science", 50000, 15);

    cout << "=== Student ===\n";
    student.displayInfo();
    cout << "\n=== Professor ===\n";
    prof.displayInfo();

    return 0;
}

###Задача 3: Полиморфизм - Геометрические фигуры

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

#ifndef M_PI
const double MY_PI = 3.14159265358979323846;
#else
const double MY_PI = M_PI;
#endif

class Shape {
protected:
    string color;
    string name;

public:
    Shape(string n, string c) : name(n), color(c) {}
    virtual ~Shape() {}

    virtual double calculateArea() const = 0;
    virtual double calculatePerimeter() const = 0;
    virtual void draw() const = 0;

    virtual void displayInfo() const {
        cout << "Фигура: " << name << ", Цвет: " << color << endl;
    }
};

class Circle : public Shape {
private:
    double radius;
public:
    Circle(string c, double r) : Shape("Круг", c), radius(r) {}

    double calculateArea() const override {
        return MY_PI * radius * radius;
    }
    double calculatePerimeter() const override {
        return 2 * MY_PI * radius;
    }
    void draw() const override {
        cout << "  (рисую круг радиуса " << radius << ")\n";
    }
};

class Rectangle : public Shape {
private:
    double width, height;
public:
    Rectangle(string c, double w, double h) : Shape("Прямоугольник", c), width(w), height(h) {}

    double calculateArea() const override {
        return width * height;
    }
    double calculatePerimeter() const override {
        return 2 * (width + height);
    }
    void draw() const override {
        cout << "  (рисую прямоугольник " << width << "x" << height << ")\n";
    }
};

class Triangle : public Shape {
private:
    double a, b, c;
public:
    Triangle(string col, double a_, double b_, double c_) : Shape("Треугольник", col), a(a_), b(b_), c(c_) {}

    double calculatePerimeter() const override {
        return a + b + c;
    }
    double calculateArea() const override {
        double p = calculatePerimeter() / 2.0;
        double area = sqrt(max(0.0, p * (p - a) * (p - b) * (p - c)));
        return area;
    }
    void draw() const override {
        cout << "  (рисую треугольник со сторонами " << a << ", " << b << ", " << c << ")\n";
    }
};

int main() {
    vector<Shape*> shapes;
    shapes.push_back(new Circle("Красный", 5.0));
    shapes.push_back(new Rectangle("Синий", 4.0, 6.0));
    shapes.push_back(new Triangle("Зеленый", 3.0, 4.0, 5.0));

    for (const auto s : shapes) {
        s->displayInfo();
        cout << "Площадь: " << s->calculateArea() << ", Периметр: " << s->calculatePerimeter() << endl;
        s->draw();
        cout << "--------------------------\n";
    }

    for (auto s : shapes) delete s;
    return 0;
}

##Задача 4: Абстрактный класс "Транспортное средство"
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Vehicle {
protected:
    string brand;
    string model;
    int year;
    double fuelLevel; // процент 0..100

public:
    Vehicle(string b, string m, int y) : brand(b), model(m), year(y), fuelLevel(100.0) {}
    virtual ~Vehicle() {}

    virtual void startEngine() = 0;
    virtual void stopEngine() = 0;
    virtual void refuel(double amount) = 0;

    virtual void displayInfo() const {
        cout << brand << " " << model << " (" << year << ")\n";
        cout << "Уровень топлива: " << fuelLevel << "%\n";
    }

    double getFuelLevel() const { return fuelLevel; }
    void setFuelLevel(double level) {
        if (level < 0) level = 0;
        if (level > 100) level = 100;
        fuelLevel = level;
    }
};

class Car : public Vehicle {
private:
    int doors;
    string transmission;
    bool engineOn;
public:
    Car(string b, string m, int y, int d, string trans)
        : Vehicle(b,m,y), doors(d), transmission(trans), engineOn(false) {}

    void startEngine() override {
        if (!engineOn) {
            engineOn = true;
            cout << brand << " " << model << " двигатель запущен\n";
        } else cout << "Двигатель уже запущен\n";
    }

    void stopEngine() override {
        if (engineOn) {
            engineOn = false;
            cout << brand << " " << model << " двигатель остановлен\n";
        } else cout << "Двигатель уже остановлен\n";
    }

    void refuel(double amount) override {
        setFuelLevel(fuelLevel + amount);
        cout << brand << " " << model << " заправлен на " << amount << "%. Текущий уровень: " << fuelLevel << "%\n";
    }

    void displayInfo() const override {
        Vehicle::displayInfo();
        cout << "Двери: " << doors << ", Коробка: " << transmission << "\n";
    }
};

class Motorcycle : public Vehicle {
private:
    bool hasFairing;
    bool engineOn;

public:
    Motorcycle(string b, string m, int y, bool fairing)
        : Vehicle(b,m,y), hasFairing(fairing), engineOn(false) {}

    void startEngine() override {
        if (!engineOn) {
            engineOn = true;
            cout << brand << " " << model << " мотор запущен\n";
        } else cout << "Мотор уже запущен\n";
    }

    void stopEngine() override {
        if (engineOn) {
            engineOn = false;
            cout << brand << " " << model << " мотор остановлен\n";
        } else cout << "Мотор уже остановлен\n";
    }

    void refuel(double amount) override {
        setFuelLevel(fuelLevel + amount);
        cout << brand << " " << model << " заправлен на " << amount << "%. Текущий уровень: " << fuelLevel << "%\n";
    }

    void wheelie() {
        cout << brand << " " << model << " делает вилли!\n";
    }

    void displayInfo() const override {
        Vehicle::displayInfo();
        cout << "Обтекатель: " << (hasFairing ? "есть" : "нет") << "\n";
    }
};

int main() {
    vector<Vehicle*> fleet;
    fleet.push_back(new Car("Toyota", "Camry", 2020, 4, "Automatic"));
    fleet.push_back(new Motorcycle("Yamaha", "MT-07", 2019, false));

    for (auto v : fleet) {
        v->displayInfo();
        v->refuel(-20); // уменьшим уровень топлива на 20% (в примере можно и >0)
        v->displayInfo();
        cout << "----\n";
    }

    // Уникальная функциональность мотоцикла
    Motorcycle* m = dynamic_cast<Motorcycle*>(fleet[1]);
    if (m) { m->startEngine(); m->wheelie(); m->stopEngine(); }

    for (auto v : fleet) delete v;
    return 0;
}



###Задача 5: Композиция - Библиотека и Книги


#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

class Book {
private:
    string title;
    string author;
    string isbn;
    int year;
    bool isAvailable;

public:
    Book(const string& t, const string& a, const string& i, int y)
        : title(t), author(a), isbn(i), year(y), isAvailable(true) {}

// Геттеры
    string getTitle() const { return title; }
    string getAuthor() const { return author; }
    string getIsbn() const { return isbn; }
    int getYear() const { return year; }
    bool available() const { return isAvailable; }

    // Сеттеры
    void setTitle(const string& t) { title = t; }
    void setAuthor(const string& a) { author = a; }
    void setIsbn(const string& i) { isbn = i; }
    void setYear(int y) { year = y; }

    // Методы управления доступностью
    bool borrow() {
        if (!isAvailable) return false;
        isAvailable = false;
        return true;
    }

    bool returnBook() {
        if (isAvailable) return false;
        isAvailable = true;
        return true;
    }

    void displayInfo() const {
        cout << "Название: " << title << " | Автор: " << author
             << " | ISBN: " << isbn << " | Год: " << year
             << " | " << (isAvailable ? "Доступна" : "Занята") << endl;
    }
};

class Library {
private:
    string name;
    string address;
    vector<Book> books;

public:
    Library(const string& n, const string& addr) : name(n), address(addr) {}

    void addBook(const Book& book) {
        // Не добавляем дубликат ISBN
        auto it = find_if(books.begin(), books.end(),
                          [&](const Book& b){ return b.getIsbn() == book.getIsbn(); });
        if (it == books.end()) {
            books.push_back(book);
        } else {
            cerr << "Книга с ISBN " << book.getIsbn() << " уже существует — пропуск.\n";
        }
    }

    bool removeBook(const string& isbn) {
        auto it = remove_if(books.begin(), books.end(),
                            [&](const Book& b){ return b.getIsbn() == isbn; });
        if (it != books.end()) {
            books.erase(it, books.end());
            return true;
        }
        return false;
    }

    // Возвращает указатель на книгу внутри вектора или nullptr
    Book* findBookByTitle(const string& title) {
        auto it = find_if(books.begin(), books.end(),
                          [&](Book& b){ return b.getTitle() == title; });
        return (it != books.end()) ? &(*it) : nullptr;
    }

    Book* findBookByIsbn(const string& isbn) {
        auto it = find_if(books.begin(), books.end(),
                          [&](Book& b){ return b.getIsbn() == isbn; });
        return (it != books.end()) ? &(*it) : nullptr;
    }

    bool borrowBook(const string& isbn) {
        Book* b = findBookByIsbn(isbn);
        if (!b) {
            cerr << "Книга с ISBN " << isbn << " не найдена.\n";
            return false;
        }
        if (!b->borrow()) {
            cerr << "Книга \"" << b->getTitle() << "\" сейчас недоступна.\n";
            return false;
        }
        cout << "Книга \"" << b->getTitle() << "\" выдана.\n";
        return true;
    }

    bool returnBook(const string& isbn) {
        Book* b = findBookByIsbn(isbn);
        if (!b) {
            cerr << "Книга с ISBN " << isbn << " не найдена.\n";
            return false;
        }
        if (!b->returnBook()) {
            cerr << "Книга \"" << b->getTitle() << "\" уже была отмечена как доступная.\n";
            return false;
        }
        cout << "Книга \"" << b->getTitle() << "\" возвращена.\n";
        return true;
    }

    void displayAllBooks() const {
        cout << "Библиотека: " << name << " (" << address << ") — все книги:\n";
        for (const auto& b : books) b.displayInfo();
    }

    void displayAvailableBooks() const {
        cout << "Доступные книги:\n";
        for (const auto& b : books) if (b.available()) b.displayInfo();
    }
};

int main() {
    Library lib("Городская библиотека", "ул. Центральная, 1");

    lib.addBook(Book("Преступление и наказание", "Ф. Достоевский", "978-5-01-000000-1", 1866));
    lib.addBook(Book("Война и мир", "Л. Толстой", "978-5-01-000000-2", 1869));
    lib.addBook(Book("Мастер и Маргарита", "М. Булгаков", "978-5-01-000000-3", 1967));

    lib.displayAllBooks();
    cout << endl;

// Выдача книги
    lib.borrowBook("978-5-01-000000-2"); // Война и мир
    cout << endl;

    lib.displayAvailableBooks();
    cout << endl;

    // Попытка повторной выдачи той же книги
    lib.borrowBook("978-5-01-000000-2");
    cout << endl;

    // Возврат
    lib.returnBook("978-5-01-000000-2");
    cout << endl;

    lib.displayAllBooks();

    // Удаление
    lib.removeBook("978-5-01-000000-1");
    cout << "\nПосле удаления:\n";
    lib.displayAllBooks();

    return 0;
}


###Задача 6: Статические члены и константы

#include <iostream>
#include <string>
using namespace std;

class BankAccount {
private:
    string accountNumber;
    string ownerName;
    double balance;
    static int totalAccounts;           // Общее количество счетов
    static double totalBankBalance;     // Общий баланс банка
    const double MIN_BALANCE = 10.0;    // Минимальный баланс

public:
    BankAccount(const string& accNum, const string& owner, double initial)
        : accountNumber(accNum), ownerName(owner), balance(initial) {
        if (balance < MIN_BALANCE) {
            cout << "Начальный баланс меньше минимального, установлен " << MIN_BALANCE << endl;
            balance = MIN_BALANCE;
        }
        totalAccounts++;
        totalBankBalance += balance;
    }

    ~BankAccount() {
        totalAccounts--;
        totalBankBalance -= balance;
    }

    void deposit(double amount) {
        if (amount <= 0) {
            cout << "Нельзя внести отрицательную сумму!\n";
            return;
        }
        balance += amount;
        totalBankBalance += amount;
    }

    void withdraw(double amount) {
        if (amount <= 0) {
            cout << "Некорректная сумма!\n";
            return;
        }
        if (balance - amount < MIN_BALANCE) {
            cout << "Нельзя снять: минимальный баланс должен быть " << MIN_BALANCE << endl;
            return;
        }
        balance -= amount;
        totalBankBalance -= amount;
    }

    void displayAccountInfo() const {
        cout << "Счет №" << accountNumber << " | Владелец: " << ownerName
             << " | Баланс: " << balance << endl;
    }

    // Статические методы
    static int getTotalAccounts() { return totalAccounts; }
    static double getTotalBankBalance() { return totalBankBalance; }
    static double getAverageBalance() {
        if (totalAccounts == 0) return 0.0;
        return totalBankBalance / totalAccounts;
    }
};

// Инициализация статических переменных
int BankAccount::totalAccounts = 0;
double BankAccount::totalBankBalance = 0.0;

int main() {
    cout << "=== Создание счетов ===\n";
    BankAccount acc1("001", "Иван Иванов", 1000);
    BankAccount acc2("002", "Петр Петров", 200);
    BankAccount acc3("003", "Мария Сидорова", 50);

    acc1.displayAccountInfo();
    acc2.displayAccountInfo();
    acc3.displayAccountInfo();

    cout << "\nВсего счетов: " << BankAccount::getTotalAccounts() << endl;
    cout << "Общий баланс банка: " << BankAccount::getTotalBankBalance() << endl;
    cout << "Средний баланс: " << BankAccount::getAverageBalance() << endl;

    cout << "\n=== Операции по счетам ===\n";
    acc1.deposit(500);
    acc2.withdraw(100);
    acc3.withdraw(80); // Ошибка — ниже MIN_BALANCE

    cout << "\nПосле операций:\n";
    acc1.displayAccountInfo();
    acc2.displayAccountInfo();
    acc3.displayAccountInfo();

    cout << "\nВсего счетов: " << BankAccount::getTotalAccounts() << endl;
    cout << "Общий баланс банка: " << BankAccount::getTotalBankBalance() << endl;
    cout << "Средний баланс: " << BankAccount::getAverageBalance() << endl;

    cout << "\n=== Конец программы ===\n";
    return 0;
}
####Задача 7: Дружественные функции и операторы
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

class Complex {
private:
    double real;
    double imaginary;

public:
    Complex(double r = 0, double i = 0) : real(r), imaginary(i) {}
    
    double getReal() const { return real; }
    double getImaginary() const { return imaginary; }
    void setReal(double r) { real = r; }
    void setImaginary(double i) { imaginary = i; }
    
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imaginary + other.imaginary);
    }
    
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imaginary - other.imaginary);
    }
    
    Complex operator*(const Complex& other) const {
        return Complex(real * other.real - imaginary * other.imaginary,
                      real * other.imaginary + imaginary * other.real);
    }
    
    bool operator==(const Complex& other) const {
        return real == other.real && imaginary == other.imaginary;
    }
    
    friend ostream& operator<<(ostream& os, const Complex& c);
    friend istream& operator>>(istream& is, Complex& c);
    
    void display() const {
        cout << real << " + " << imaginary << "i" << endl;
    }
};

ostream& operator<<(ostream& os, const Complex& c) {
    if (c.imaginary >= 0)
        os << c.real << " + " << c.imaginary << "i";
    else
        os << c.real << " - " << -c.imaginary << "i";
    return os;
}

istream& operator>>(istream& is, Complex& c) {
    cout << "Enter real and imaginary parts: ";
    is >> c.real >> c.imaginary;
    return is;
}

int main() {
    Complex c1(3, 4);
    Complex c2(1, -2);
    Complex c3;
    
    cout << "Complex numbers:" << endl;
    cout << "c1 = " << c1 << endl;
    cout << "c2 = " << c2 << endl;
    
    cout << "\nArithmetic operations:" << endl;
    Complex sum = c1 + c2;
    Complex diff = c1 - c2;
    Complex product = c1 * c2;
    
    cout << "c1 + c2 = " << sum << endl;
    cout << "c1 - c2 = " << diff << endl;
    cout << "c1 * c2 = " << product << endl;
    
    cout << "\nComparison:" << endl;
    cout << "c1 == c2: " << (c1 == c2 ? "true" : "false") << endl;
    cout << "c1 == c1: " << (c1 == c1 ? "true" : "false") << endl;
    
    cout << "\nEnter a new complex number:" << endl;
    cin >> c3;
    cout << "You entered: " << c3 << endl;
    
    cout << "c3 + c1 = " << (c3 + c1) << endl;
    
    return 0;
}

###Задача 8: Множественное наследование

#include <iostream>
#include <string>
using namespace std;

class Person {
protected:
    string name;
    int age;

public:
    Person(string n, int a) : name(n), age(a) {}
    virtual void display() const {
        cout << "Имя: " << name << ", Возраст: " << age << endl;
    }
};

class Employee {
protected:
    string position;
    double salary;

public:
    Employee(string pos, double sal) : position(pos), salary(sal) {}
    virtual void work() const {
        cout << "Выполняет работу как сотрудник" << endl;
    }
};

class Teacher : public Person, public Employee {
private:
    string subject;
    int experienceYears;

public:
    Teacher(string n, int a, string pos, double sal, string subj, int exp)
        : Person(n, a), Employee(pos, sal), subject(subj), experienceYears(exp) {}
    
    void display() const override {
        Person::display();
        cout << "Должность: " << position << ", Зарплата: " << salary << endl;
        cout << "Предмет: " << subject << ", Опыт: " << experienceYears << " лет" << endl;
    }
    
    void work() const override {
        cout << "Преподает предмет: " << subject << endl;
    }
    
    void gradeStudents() const {
        cout << "Проверяет работы студентов по предмету " << subject << endl;
    }
    
    void prepareLesson() const {
        cout << "Готовит урок по " << subject << endl;
    }
};

class Researcher {
protected:
    string researchArea;
    int publicationsCount;

public:
    Researcher(string area, int publications) 
        : researchArea(area), publicationsCount(publications) {}
    
    void conductResearch() const {
        cout << "Проводит исследования в области: " << researchArea << endl;
    }
};

class Professor : public Teacher, public Researcher {
public:
    Professor(string n, int a, string pos, double sal, string subj, int exp, 
              string area, int publications)
        : Teacher(n, a, pos, sal, subj, exp), 
          Researcher(area, publications) {}
    
    void display() const override {
        Teacher::display();
        cout << "Область исследований: " << researchArea << endl;
        cout << "Количество публикаций: " << publicationsCount << endl;
    }
    
    void work() const override {
        cout << "Профессор преподает " << subject << " и исследует " << researchArea << endl;
    }
    
    void supervisePhD() const {
        cout << "Руководит аспирантами в области " << researchArea << endl;
    }
};

int main() {
    cout << "=== Учитель ===" << endl;
    Teacher teacher("Анна Иванова", 35, "Учитель", 50000, "Математика", 10);
    teacher.display();
    teacher.work();
    teacher.gradeStudents();
    teacher.prepareLesson();
    
    cout << "\n=== Профессор ===" << endl;
    Professor prof("Дмитрий Петров", 45, "Профессор", 80000, "Физика", 15, 
                   "Квантовая механика", 25);
    prof.display();
    prof.work();
    prof.conductResearch();
    prof.supervisePhD();
    prof.gradeStudents();
    
    return 0;
}


####Задача 9: Шаблоны классов
#include <iostream>
#include <vector>
#include <string>
using namespace std;

template<typename T>
class Stack {
private:
    vector<T> elements;
    int capacity;

public:
    Stack(int size = 10) : capacity(size) {}

    void push(const T& element) {
        if (elements.size() < capacity) {
            elements.push_back(element);
        } else {
            cout << "Stack is full!" << endl;
        }
    }

    T pop() {
        if (!elements.empty()) {
            T value = elements.back();
            elements.pop_back();
            return value;
        } else {
            cout << "Stack is empty!" << endl;
            return T();
        }
    }

    T top() const {
        if (!elements.empty()) {
            return elements.back();
        } else {
            cout << "Stack is empty!" << endl;
            return T();
        }
    }

    bool isEmpty() const {
        return elements.empty();
    }

    bool isFull() const {
        return elements.size() >= capacity;
    }

    int size() const {
        return elements.size();
    }

    void display() const {
        cout << "Stack: ";
        for (const auto& elem : elements) {
            cout << elem << " ";
        }
        cout << endl;
    }
};

template<typename T>
class Queue {
private:
    vector<T> elements;
    int capacity;

public:
    Queue(int size = 10) : capacity(size) {}

    void enqueue(const T& element) {
        if (elements.size() < capacity) {
            elements.push_back(element);
        } else {
            cout << "Queue is full!" << endl;
        }
    }

    T dequeue() {
        if (!elements.empty()) {
            T value = elements.front();
            elements.erase(elements.begin());
            return value;
        } else {
            cout << "Queue is empty!" << endl;
            return T();
        }
    }

    T front() const {
        if (!elements.empty()) {
            return elements.front();
        } else {
            cout << "Queue is empty!" << endl;
            return T();
        }
    }

    bool isEmpty() const {
        return elements.empty();
    }

    bool isFull() const {
        return elements.size() >= capacity;
    }

    int size() const {
        return elements.size();
    }

    void display() const {
        cout << "Queue: ";
        for (const auto& elem : elements) {
            cout << elem << " ";
        }
        cout << endl;
    }
};

int main() {
    cout << "=== Stack<int> Test ===" << endl;
    Stack<int> s1(3);
    s1.push(10);
    s1.push(20);
    s1.push(30);
    s1.display();
    cout << "Top: " << s1.top() << endl;
    cout << "Pop: " << s1.pop() << endl;
    s1.display();

    cout << "\n=== Stack<string> Test ===" << endl;
    Stack<string> s2(2);
    s2.push("Hello");
    s2.push("World");
    s2.display();
    cout << "Top: " << s2.top() << endl;
    s2.pop();
    s2.display();

    cout << "\n=== Queue<int> Test ===" << endl;
    Queue<int> q1(3);
    q1.enqueue(1);
    q1.enqueue(2);
    q1.enqueue(3);
    q1.display();
    cout << "Front: " << q1.front() << endl;
    cout << "Dequeue: " << q1.dequeue() << endl;
    q1.display();

    cout << "\n=== Queue<string> Test ===" << endl;
    Queue<string> q2(2);
    q2.enqueue("Apple");
    q2.enqueue("Banana");
    q2.display();
    cout << "Front: " << q2.front() << endl;
    q2.dequeue();
    q2.display();

    return 0;
}


###Задача 10: Полная система с использованием всех принципов ООП
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>
using namespace std;

class UniversityMember {
protected:
    string name;
    string id;
    string email;

public:
    UniversityMember(string n, string i, string e) : name(n), id(i), email(e) {}
    virtual ~UniversityMember() {}

    virtual void displayInfo() const = 0;
    virtual void work() const = 0;
    virtual string getRole() const = 0;

    string getId() const { return id; }
    string getName() const { return name; }
};

class Student : public UniversityMember {
private:
    string major;
    int year;
    double gpa;
    vector<string> courses;

public:
    Student(string n, string i, string e, string mj, int yr)
        : UniversityMember(n, i, e), major(mj), year(yr), gpa(0.0) {
    }

    void enrollCourse(const string& course) {
        courses.push_back(course);
    }

    void dropCourse(const string& course) {
        auto it = find(courses.begin(), courses.end(), course);
        if (it != courses.end()) courses.erase(it);
    }

    void calculateGPA() {
        if (courses.empty()) {
            gpa = 0.0;
        }
        else {
            gpa = 2.0 + (static_cast<double>(courses.size()) / 10.0);
            if (gpa > 4.0) gpa = 4.0;
        }
    }

    void displayInfo() const override {
        cout << "Student: " << name << " | ID: " << id << " | Email: " << email
            << " | Major: " << major << " | Year: " << year << " | GPA: " << gpa << endl;
        cout << "  Courses: ";
        for (const auto& c : courses) cout << c << " ";
        cout << endl;
    }

    void work() const override {
        cout << name << " is studying and doing assignments." << endl;
    }

    string getRole() const override { return "Student"; }
    const vector<string>& getCourses() const { return courses; }
    double getGPA() const { return gpa; }
};

class Professor : public UniversityMember {
private:
    string department;
    string office;
    double salary;
    vector<string> teachingCourses;

public:
    Professor(string n, string i, string e, string dept, string off, double sal)
        : UniversityMember(n, i, e), department(dept), office(off), salary(sal) {
    }

    void assignCourse(const string& course) {
        teachingCourses.push_back(course);
    }

    void removeCourse(const string& course) {
        auto it = find(teachingCourses.begin(), teachingCourses.end(), course);
        if (it != teachingCourses.end()) teachingCourses.erase(it);
    }

    double calculateSalary() const {
        return salary + (50.0 * teachingCourses.size());
    }

    void displayInfo() const override {
        cout << "Professor: " << name << " | ID: " << id << " | Email: " << email
            << " | Dept: " << department << " | Office: " << office
            << " | Salary: " << salary << " | Total: " << calculateSalary() << endl;
        cout << "  Teaching: ";
        for (const auto& c : teachingCourses) cout << c << " ";
        cout << endl;
    }

    void work() const override {
        cout << name << " is teaching and preparing lectures." << endl;
    }

    string getRole() const override { return "Professor"; }
    const vector<string>& getTeachingCourses() const { return teachingCourses; }
};

class Course {
private:
    string courseCode;
    string courseName;
    int credits;
    Professor* instructor;
    vector<Student*> enrolledStudents;

public:
    Course(string code, string name, int cr)
        : courseCode(code), courseName(name), credits(cr), instructor(nullptr) {
    }

    void addStudent(Student* student) {
        if (!student) return;
        enrolledStudents.push_back(student);
        student->enrollCourse(courseCode);
    }

    void removeStudent(const string& studentId) {
        enrolledStudents.erase(
            remove_if(enrolledStudents.begin(), enrolledStudents.end(),
                [&](Student* s) {
                    if (s && s->getId() == studentId) {
                        s->dropCourse(courseCode);
                        return true;
                    }
                    return false;
                }),
            enrolledStudents.end());
    }

    void setInstructor(Professor* prof) {
        instructor = prof;
        if (prof) prof->assignCourse(courseCode);
    }

    void displayCourseInfo() const {
        cout << "Course: " << courseCode << " - " << courseName << " (" << credits << " credits)" << endl;
        if (instructor) cout << "  Instructor: " << instructor->getName() << endl;
        else cout << "  Instructor: TBA" << endl;
        cout << "  Students: ";
        for (const auto& s : enrolledStudents) {
            if (s) cout << s->getName() << "(" << s->getId() << ") ";
        }
        cout << endl;
    }

    string getCode() const { return courseCode; }
};

class University {
private:
    string name;
    vector<unique_ptr<UniversityMember>> members;
    vector<unique_ptr<Course>> courses;
    static int totalUniversities;

public:
    University(string n) : name(n) { totalUniversities++; }
    ~University() { totalUniversities--; }

    Student* addStudent(const string& n, const string& i, const string& e, const string& major, int year) {
        auto ptr = make_unique<Student>(n, i, e, major, year);
        Student* raw = ptr.get();
        members.push_back(move(ptr));
        return raw;
    }

    Professor* addProfessor(const string& n, const string& i, const string& e, const string& dept, const string& office, double salary) {
        auto ptr = make_unique<Professor>(n, i, e, dept, office, salary);
        Professor* raw = ptr.get();
        members.push_back(move(ptr));
        return raw;
    }

    Course* addCourse(const string& code, const string& name, int credits) {
        auto cptr = make_unique<Course>(code, name, credits);
        Course* raw = cptr.get();
        courses.push_back(move(cptr));
        return raw;
    }

    UniversityMember* findMemberById(const string& id) {
        for (auto& m : members) {
            if (m->getId() == id) return m.get();
        }
        return nullptr;
    }

    Course* findCourseByCode(const string& code) {
        for (auto& c : courses) {
            if (c->getCode() == code) return c.get();
        }
        return nullptr;
    }

    bool enrollStudentInCourse(const string& studentId, const string& courseCode) {
        UniversityMember* um = findMemberById(studentId);
        Course* c = findCourseByCode(courseCode);
        if (!um || !c) return false;
        Student* s = dynamic_cast<Student*>(um);
        if (!s) return false;
        c->addStudent(s);
        s->calculateGPA();
        return true;
    }

    bool assignInstructorToCourse(const string& profId, const string& courseCode) {
        UniversityMember* um = findMemberById(profId);
        Course* c = findCourseByCode(courseCode);
        if (!um || !c) return false;
        Professor* p = dynamic_cast<Professor*>(um);
        if (!p) return false;
        c->setInstructor(p);
        return true;
    }

    void displayAllMembers() const {
        cout << "\nMembers of " << name << ":\n";
        for (const auto& m : members) m->displayInfo();
    }

    void displayAllCourses() const {
        cout << "\nCourses at " << name << ":\n";
        for (const auto& c : courses) c->displayCourseInfo();
    }

    static int getTotalUniversities() { return totalUniversities; }
};

int University::totalUniversities = 0;

int main() {
    University uni("Simple University");

    Student* s1 = uni.addStudent("Alice", "S001", "alice@mail.com", "CS", 2);
    Student* s2 = uni.addStudent("Bob", "S002", "bob@mail.com", "Math", 1);

    Professor* p1 = uni.addProfessor("Dr. Smith", "P001", "smith@mail.com", "CS", "RM101", 3000.0);
    Professor* p2 = uni.addProfessor("Dr. Lee", "P002", "lee@mail.com", "Math", "RM102", 3200.0);

    Course* c1 = uni.addCourse("CS101", "Intro to CS", 3);
    Course* c2 = uni.addCourse("MATH101", "Calculus I", 4);

    uni.assignInstructorToCourse("P001", "CS101");
    uni.assignInstructorToCourse("P002", "MATH101");

    uni.enrollStudentInCourse("S001", "CS101");
    uni.enrollStudentInCourse("S002", "MATH101");
    uni.enrollStudentInCourse("S001", "MATH101");

    uni.displayAllMembers();
    uni.displayAllCourses();

    cout << "\nTotal universities: " << University::getTotalUniversities() << endl;
    return 0;
}











